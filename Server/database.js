
// SQLite is small, file based database. It's relatively simple and light to use. However, it does not scale to 
// large
var fs = require("fs")
var _ = require("lodash")
var file = "measurements.db"
var dbCreated = fs.existsSync(file);


if(!dbCreated) {
	console.log("DB: Creating database file: " + file);
	fs.openSync(file, "w");
}


var sqlite3 = require("sqlite3").verbose();
var db = new sqlite3.Database(file);


db.serialize(function(){
	// If database does not exist, create the tables
	if(!dbCreated){
		console.log("DB: Creating tables")
		db.run("CREATE TABLE Nodes (NodeId integer NOT NULL PRIMARY KEY, NodeName TEXT NOT NULL UNIQUE, Description TEXT)")
		db.run("CREATE TABLE Sensors (SensorId integer NOT NULL PRIMARY KEY, Type TEXT, NodeId integer, FOREIGN KEY (NodeId) REFERENCES Nodes(NodeId))")
		db.run("CREATE TABLE Measurements (M_Id integer NOT NULL PRIMARY KEY, Timestamp TEXT, DValue REAL, SensorId integer, FOREIGN KEY (SensorId) REFERENCES Sensors(SensorId))")
		
	}
	console.log("DB: Adding test data")
	addNode("TF105", "Kuvaus")
	addNode("TF106", "Kuvaus2")
	
})


// Adds new node to the database only if it did not exist before
// To ensure uniqueness of the id in database, the NodeId is autogenerated 
function addNode(nodeName, description)
{
	console.log("DB: adding ", nodeName)
	// Javascript is asynchronous language. With database, where queries can take a while to run, than can cause problems.
	// If for example insert requires checking something beforehands, such as existence of the node, we must make sure that the 
	// results have been received before proceeding, that is why the use of Promises here.
	return new Promise( function (resolve, reject)
	{
		// db.get gets single result
		db.get("SELECT NodeId FROM Nodes WHERE NodeName = ?", [nodeName], function (err, row)
		{
			if (err)
			{
				console.log("DB: Error while adding node")
				reject("DB: Error while adding node")
			}
			// New node is created only if it did not exist before.
			// Row contains the results (or the lack of results) from the select-query above)
			if (!row)
			{
				// db.run just runs the sql
				db.run("INSERT INTO Nodes (NodeId, NodeName, Description) VALUES (?,?,?)", [null, nodeName, description], function (err, row)
				{
					if (err)
					{
						// Rejecting the promise
						console.log(err)
						reject("DB: Error while inserting node")
					}			
				
					db.get("SELECT NodeId FROM Nodes WHERE NodeName = ?", [nodeName], function (err, row)
					{
						if (err)
						{
							console.log("DB: Error while adding node")
							reject("DB: Error while adding node")
						}
						else
						{
							console.log(row)
							resolve(row.NodeId)
						}
					})
				})
			}
			else
			{
				console.log("DB: Existed")
				resolve(row.NodeId)
			}
			
		})
	})
		
}

function getNodes()
{
	return new Promise (function (resolve, reject)
	{
		// db.all returns all the results in a bunch. db.each would do the callback code separately for each of the result rows
		db.all("SELECT * FROM Nodes", function(err, rows)
		{
			if (err)
			{
				reject("DB: Error while getting nodes")
			}
			else
			{
				console.log(rows)
				resolve(rows)
				
			}
		})
		
	})
}
function getNode(nodeId)
{
	return new Promise (function (resolve, reject)
	{
		// db.all returns all the results in a bunch. db.each would do the callback code separately for each of the result rows
		db.get("SELECT * FROM Nodes WHERE NodeId = ?", [nodeId], function(err, row)
		{
			if (err)
			{
				reject("DB: Error while getting nodeinformation")
			}
			else
			{
				console.log("DB: " +row)
				resolve(row)
				
			}
		})
		
	})
}

function updateNode(nodeId, new_nodeName, new_description)
{
	return new Promise (function (resolve, reject)
	{
		db.run("UPDATE Nodes SET NodeName = ?, Description = ? WHERE NodeId = ?", [new_nodeName, new_description, nodeId], function (err, row)
		{
			if (err)
			{
				console.log(err)
				reject("DB: Error while updating node ", nodeId)
			}
			else
			{
				resolve("DB: Updated " + nodeId)
			}
		
		})
	})
}

// You can add new functions here to do different things that is required in your rest api. Look the four functions above for code help.

// Adds new sensor to the database 
// To ensure uniqueness of the id in database, the sensorId is autogenerated 
function addSensor(nodeId, type)
{
	console.log("adding a sensor of type:", type)
	// Javascript is asynchronous language. With database, where queries can take a while to run, than can cause problems.
	// If for example insert requires checking something beforehands, such as existence of the sensor, we must make sure that the 
	// results have been received before proceeding, that is why the use of Promises here.
	return new Promise( function (resolve, reject)
	{
		// db.run just runs the sql
		db.run("INSERT INTO Sensors (SensorId, Type, NodeId) VALUES (?,?,?)", [null, type, nodeId], function (err, row)
		{
			if (err)
			{
				// Rejecting the promise
				console.log(err)
				reject("DB: Error while inserting sensor")
			}			
		})
	})
		
}

// Adds new sensor to the database 
// To ensure uniqueness of the id in database, the sensorId is autogenerated 
function addMeasurement(sensorId, timestamp, value)
{
	console.log("DB: adding a measurement. Timestamp: ", timestamp , " value: ", value)
	// Javascript is asynchronous language. With database, where queries can take a while to run, than can cause problems.
	// If for example insert requires checking something beforehands, such as existence of the sensor, we must make sure that the 
	// results have been received before proceeding, that is why the use of Promises here.
	return new Promise( function (resolve, reject)
	{
		// db.run just runs the sql
		db.run("INSERT INTO Measurements (M_Id, Timestamp, DValue, SensorId) VALUES (?,?,?,?)", [null, timestamp, value, sensorId], function (err, row)
		{
			if (err)
			{
				// Rejecting the promise
				console.log(err)
				reject("DB: Error while inserting measurement")
			}			
		})
	})
		
}

function getMeasurements()
{
	console.log("DB: Getting all Measurements")
	return new Promise (function (resolve, reject)
	{
		// db.all returns all the results in a bunch. db.each would do the callback code separately for each of the result rows
		db.all("SELECT * FROM Measurements", function(err, rows)
		{
			if (err)
			{
				reject("DB: Error while getting measurements")
			}
			else
			{
				console.log(rows)
				resolve(rows)
				
			}
		})
		
	})
}

// --------- EXPORTS ---------
// Add here the functions you wish to have visible outside 


module.exports = 
{
	addNode,
	getNodes,
	updateNode,
	getNode,
	addSensor,
	addMeasurement,
	getMeasurements
}